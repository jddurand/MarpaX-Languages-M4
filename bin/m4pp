#!perl
use Encode;
use Encode::Locale;
use POSIX qw/EXIT_SUCCESS/;
use MarpaX::Languages::M4::Impl::GNU;
use Log::Any;
use Log::Any::Adapter;
use Log::Any::Adapter::Callback;

# VERSION

# PODNAME: m4pp

# ABSTRACT: M4 implementation in Perl

#
# Get the numbers associated to levels
#
my @logging_methods = Log::Any->logging_methods;
my $i = -1;
my %logging_levels = map {++$i; $logging_methods[$i] => $i} (0..$#logging_methods);
#
# Set logger
#
Log::Any::Adapter->set('Callback', min_level => 'trace', logging_cb => \&_logging_cb);
#
# Call implementation
#
my $impl = MarpaX::Languages::M4::Impl::GNU->new_with_options();
print $impl->impl_value;
exit($impl->impl_rc);

sub _logging_cb {
  my ($method, $self, $format, @params) = @_;

  my $level = $logging_levels{$method};
  print STDERR "$format @args\n";
  #
  # If level is >= error, then check debugfile
  #
  if (! defined($level)) {
    return;
  }
  my $fh;
  open($fh, '>>&STDERR');
  my $fhName = 'STDERR';
  if ($level >= $logging_levels{error}) {
    #
    # If called within new_with_options(), $impl
    # is not yet setted
    #
    my $thisSelf = $impl || $MarpaX::Languages::M4::SELF;
    print STDERR "\$thisSelf = " . (defined($thisSelf) ? $thisSelf : '<undef>') . "\n";
    my $debugfile = $thisSelf->impl_debugfile;
    if (defined($debugfile)) {
      if (! open($fh, '>>', $debugfile)) {
        #
        # Hmmm...
        #
        warn "Cannot open $debugfile, $!";
        $fh = \*STDERR;
      } else {
        $fhName = $debugfile;
      }
    }
  }
  if ($ENV{M4_ENCODE_LOCALE}) {
    binmode $fh, ":encoding(console_out)" if -t $fh;
  }

  printf $fh $format, @params;
  if (! close($fh)) {
    warn "Cannot close $fhName, $!";
  }
}

exit(EXIT_SUCCESS);
