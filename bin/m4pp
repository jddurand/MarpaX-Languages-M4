#!perl
use Encode;
use Encode::Locale;
use IO::Interactive qw/is_interactive/;
use POSIX qw/EXIT_SUCCESS/;
use MarpaX::Languages::M4::Impl::Default;
use Log::Any;
use Log::Any::Adapter;
use Log::Any::Adapter::Callback;

# ABSTRACT: M4 implementation in Perl

# VERSION

# AUTHORITY

# PODNAME: m4pp

#
# Get the numbers associated to levels
#
my @logging_methods = Log::Any->logging_methods;
my $i = -1;
my %logging_levels = map {++$i; $logging_methods[$i] => $i} (0..$#logging_methods);
#
# Set logger
#
Log::Any::Adapter->set('Callback', min_level => 'trace', logging_cb => \&_logging_cb);
#
# Call implementation
#
my $impl = MarpaX::Languages::M4::Impl::Default->new_with_options();
print $impl->impl_value;
exit($impl->impl_rc);

sub _logging_cb {
  my ($method, $self, $format, @params) = @_;

  my $level = $logging_levels{$method};
  #
  # If level is >= error, then check debugfile
  #
  if (! defined($level)) {
    return;
  }
  #
  # If called within new_with_options(), $impl
  # is not yet setted
  #
  my $_impl = $impl || $MarpaX::Languages::M4::SELF;

  my $fh;
  open($fh, '>>&STDERR');
  my $fhName = 'STDERR';
  my $prefix;
  if ($level >= $logging_levels{error}) {
    my $debugfile = $_impl->impl_debugfile;
    if (defined($debugfile)) {
      if (! open($fh, '>>', $debugfile)) {
        #
        # Hmmm...
        #
        warn "Cannot open $debugfile, $!";
        $fh = \*STDERR;
      } else {
        $fhName = $debugfile;
      }
    }
    $prefix = 'm4error: ';
  } elsif ($level >= $logging_levels{warning}) {
      $prefix = '';
  } else {
      $prefix = sprintf('%s: -%d- ', 'm4trace', $_impl->impl_macroCallId);
  }
  if ($ENV{M4_ENCODE_LOCALE}) {
    binmode $fh, ":encoding(console_out)" if (is_interactive($fh));
  }

  my $program     = $_impl->builtin___program__;

  printf $fh "$prefix$format\n", @params;
  if (! close($fh)) {
    warn "Cannot close $fhName, $!";
  }
}

exit(EXIT_SUCCESS);
